<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dance Fluidity Feedback</title>
<style>
  body { font-family: sans-serif; text-align: center; margin: 1rem; }
  h1 { margin-bottom: 0.5rem; }
  p { margin: 0.2rem 0 1rem 0; font-size: 1rem; }
  #smoothnessBar { width: 80%; height: 20px; background: #ddd; margin: 10px auto; border-radius: 10px; overflow: hidden; }
  #fill { height: 100%; width: 0%; background: #4caf50; transition: width 0.1s; }
  #canvas { border: 1px solid #333; margin: 10px auto; display: block; background: #f9f9f9; }
</style>
</head>
<body>

<h1>Dance Fluidity Feedback</h1>
<p>Tap anywhere to start. Green trail = smooth, red = jerky.</p>

<div id="smoothnessBar"><div id="fill"></div></div>
<canvas id="canvas" width="300" height="300"></canvas>

<script>
let audioCtx, oscillator, gainNode;
let started = false;

let accMagBuffer = [];
let jerkBuffer = [];
const WINDOW_SIZE = 25;
const alpha = 0.1; // stronger smoothing
const baseFreq = 220;
const maxFreq = 440; // smaller pitch range
const fill = document.getElementById("fill");

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let trail = [];
const TRAIL_LENGTH = 100;
const SCALE = 15;

const jerkScale = 3;
const MIN_JERK = 0.05;
const alphaHP = 0.8;

let lastRaw = {x:0, y:0, z:0};
let accHP = {x:0, y:0, z:0};
let smoothVariancePrev = 0;

// Map smoothness to color (green = smooth, red = jerky)
function smoothnessColor(pct) {
    const r = Math.floor(pct*255);
    const g = Math.floor((1-pct)*255);
    return `rgb(${r},${g},0)`;
}

// Draw trail with color gradient
function drawTrail(colors) {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (trail.length < 2) return;
    for (let i=1; i<trail.length; i++) {
        ctx.beginPath();
        ctx.moveTo(trail[i-1].x, trail[i-1].y);
        ctx.lineTo(trail[i].x, trail[i].y);
        ctx.strokeStyle = colors[i] || 'blue';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

// Devicemotion handler
function handleMotion(event) {
    if (!event.accelerationIncludingGravity) return;

    let ax = event.accelerationIncludingGravity.x || 0;
    let ay = event.accelerationIncludingGravity.y || 0;
    let az = event.accelerationIncludingGravity.z || 0;

    // High-pass filter
    accHP.x = alphaHP * (accHP.x + ax - lastRaw.x);
    accHP.y = alphaHP * (accHP.y + ay - lastRaw.y);
    accHP.z = alphaHP * (accHP.z + az - lastRaw.z);
    lastRaw = {x: ax, y: ay, z: az};

    let dx = accHP.x;
    let dy = accHP.y;
    let dz = accHP.z;
    let jerk = Math.sqrt(dx*dx + dy*dy + dz*dz) * jerkScale;

    let accMag = Math.sqrt(accHP.x**2 + accHP.y**2 + accHP.z**2);
    accMagBuffer.push(accMag);
    if (accMagBuffer.length > WINDOW_SIZE) accMagBuffer.shift();

    jerkBuffer.push(jerk);
    if (jerkBuffer.length > WINDOW_SIZE) jerkBuffer.shift();

    let meanAcc = accMagBuffer.reduce((a,b)=>a+b,0)/accMagBuffer.length;

    // Intentionality factor
    let intentFactor = jerk === 0 ? 0 : Math.min(1, meanAcc / (jerk + 0.01));
    let scaledJerk = jerk * intentFactor;
    if (scaledJerk < MIN_JERK) scaledJerk = 0;

    // Variance & smoothing
    let meanJerk = jerkBuffer.reduce((a,b)=>a+b,0)/jerkBuffer.length;
    let variance = jerkBuffer.reduce((a,b)=>a+(b-meanJerk)**2,0)/jerkBuffer.length;
    let smoothVariance = alpha*variance + (1-alpha)*smoothVariancePrev;
    smoothVariancePrev = smoothVariance;

    // Audio: pitch + subtle amplitude modulation
    if (started) {
        let targetFreq = baseFreq + Math.min(smoothVariance*200, maxFreq - baseFreq);
        oscillator.frequency.value = 0.05*targetFreq + 0.95*oscillator.frequency.value;
        gainNode.gain.value = 0.05 + 0.05*smoothVariance; // subtle modulation
    }

    // Smoothness bar
    let pct = Math.min(1, smoothVariance / 5); 
    fill.style.width = (pct*100)+'%';
    fill.style.background = smoothnessColor(pct);

    // Trail
    let pos = {
        x: canvas.width/2 + ax*SCALE*5,
        y: canvas.height/2 - ay*SCALE*5
    };
    trail.push(pos);
    if (trail.length > TRAIL_LENGTH) trail.shift();

    let colors = trail.map(() => smoothnessColor(pct));
    drawTrail(colors);
}

// Initialize
async function init() {
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
            const response = await DeviceMotionEvent.requestPermission();
            if (response !== 'granted') { alert("Motion permission denied."); return; }
        } catch (err) { alert("Motion permission error: " + err); return; }
    }

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    oscillator = audioCtx.createOscillator();
    gainNode = audioCtx.createGain();
    oscillator.type = 'triangle'; // softer than sine
    gainNode.gain.value = 0.1;
    oscillator.connect(gainNode).connect(audioCtx.destination);
    oscillator.start();
    started = true;

    window.addEventListener('devicemotion', handleMotion);
}

// Start on tap
document.body.addEventListener('click', () => { init(); });
</script>

</body>
</html>
